/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

struct _IO_FILE ;
enum __ptrace_request ;
struct timeval ;
struct user_regs_struct ;
extern int gettimeofday(struct timeval *tv , void *tz ) ;
typedef int __pid_t;
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
int PRGA(unsigned char *S , char *plaintext , unsigned char *ciphertext ) ;
extern int pthread_cond_broadcast(int *cond ) ;
char **_global_argv  =    (char **)0;
extern int posix_memalign(void **memptr , unsigned int alignment , unsigned int size ) ;
extern int getpagesize() ;
void trigger_i$nit(void) ;
extern int pthread_join(void *thread , void **value_ptr ) ;
void fake_rc4_key_i$nit(void) ;
extern int open(char const   *filename , int oflag  , ...) ;
typedef unsigned long size_t;
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
extern int pthread_barrier_destroy(int *barrier ) ;
extern int pthread_mutex_init(int *mutex , int *attr ) ;
extern int strncmp(char const   *s1 , char const   *s2 , unsigned int maxlen ) ;
extern int printf(char const   *format  , ...) ;
int _global_argc  =    0;
extern int pthread_cond_signal(int *cond ) ;
extern int pthread_barrier_init(int *barrier , int *attr , unsigned int count ) ;
extern int scanf(char const   *format  , ...) ;
void swap(unsigned char *a , unsigned char *b ) ;
extern int raise(int sig ) ;
char **_global_envp  =    (char **)0;
enum __ptrace_request {
    PTRACE_TRACEME = 0,
    PTRACE_PEEKTEXT = 1,
    PTRACE_PEEKDATA = 2,
    PTRACE_PEEKUSER = 3,
    PTRACE_POKETEXT = 4,
    PTRACE_POKEDATA = 5,
    PTRACE_POKEUSER = 6,
    PTRACE_CONT = 7,
    PTRACE_KILL = 8,
    PTRACE_SINGLESTEP = 9,
    PTRACE_GETREGS = 12,
    PTRACE_SETREGS = 13,
    PTRACE_GETFPREGS = 14,
    PTRACE_SETFPREGS = 15,
    PTRACE_ATTACH = 16,
    PTRACE_DETACH = 17,
    PTRACE_GETFPXREGS = 18,
    PTRACE_SETFPXREGS = 19,
    PTRACE_SYSCALL = 24,
    PTRACE_GET_THREAD_AREA = 25,
    PTRACE_SET_THREAD_AREA = 26,
    PTRACE_ARCH_PRCTL = 30,
    PTRACE_SYSEMU = 31,
    PTRACE_SYSEMU_SINGLESTEP = 32,
    PTRACE_SINGLEBLOCK = 33,
    PTRACE_SETOPTIONS = 16896,
    PTRACE_GETEVENTMSG = 16897,
    PTRACE_GETSIGINFO = 16898,
    PTRACE_SETSIGINFO = 16899,
    PTRACE_GETREGSET = 16900,
    PTRACE_SETREGSET = 16901,
    PTRACE_SEIZE = 16902,
    PTRACE_INTERRUPT = 16903,
    PTRACE_LISTEN = 16904,
    PTRACE_PEEKSIGINFO = 16905,
    PTRACE_GETSIGMASK = 16906,
    PTRACE_SETSIGMASK = 16907,
    PTRACE_SECCOMP_GET_FILTER = 16908,
    PTRACE_SECCOMP_GET_METADATA = 16909,
    PTRACE_GET_SYSCALL_INFO = 16910,
    PTRACE_GET_RSEQ_CONFIGURATION = 16911
} ;
extern int unlink(char const   *filename ) ;
extern double difftime(long tv1 , long tv0 ) ;
extern int pthread_barrier_wait(int *barrier ) ;
extern int puts(char const   *__s ) ;
void encrypted_flag_i$nit(void) ;
_Bool flag_checker(char *flag ) ;
extern void *memcpy(void *s1 , void const   *s2 , unsigned int size ) ;
extern int pthread_mutex_lock(int *mutex ) ;
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
extern int gethostname(char *name , unsigned int namelen ) ;
extern void *dlsym(void *handle , char *symbol ) ;
int *trigger ;
extern unsigned long strtoul(char const   *str , char const   *endptr , int base ) ;
extern void abort() ;
extern void free(void *ptr ) ;
extern int fprintf(struct _IO_FILE *stream , char const   *format  , ...) ;
int main(int argc , char **argv , char **_formal_envp ) ;
extern void signal(int sig , void *func ) ;
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
int fake_rc4_key[16] ;
typedef struct _IO_FILE FILE;
extern int mprotect(void *addr , unsigned int len , int prot ) ;
extern int close(int filedes ) ;
extern double log(double x ) ;
extern double strtod(char const   *str , char const   *endptr ) ;
extern double ceil(double x ) ;
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) srand)(unsigned int __seed ) ;
extern int fcntl(int filedes , int cmd  , ...) ;
extern int fclose(void *stream ) ;
typedef __pid_t pid_t;
extern void perror(char const   *str ) ;
extern int pthread_cond_wait(int *cond , int *mutex ) ;
extern int write(int filedes , void *buf , unsigned int nbyte ) ;
extern int pthread_cond_init(int *cond , int *attr ) ;
int RC4(char *key , char *plaintext , unsigned char *ciphertext ) ;
extern  __attribute__((__nothrow__)) long ( __attribute__((__leaf__)) ptrace)(enum __ptrace_request __request 
                                                                              , ...) ;
extern unsigned int strnlen(char const   *s , unsigned int maxlen ) ;
extern float strtof(char const   *str , char const   *endptr ) ;
struct timeval {
   long tv_sec ;
   long tv_usec ;
};
extern long clock(void) ;
extern void qsort(void *base , unsigned int nel , unsigned int width , int (*compar)(void *a ,
                                                                                     void *b ) ) ;
extern long time(long *tloc ) ;
extern int read(int filedes , void *buf , unsigned int nbyte ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rand)(void) ;
extern void *fopen(char const   *filename , char const   *mode ) ;
extern int strcmp(char const   *a , char const   *b ) ;
struct user_regs_struct {
   unsigned long long r15 ;
   unsigned long long r14 ;
   unsigned long long r13 ;
   unsigned long long r12 ;
   unsigned long long rbp ;
   unsigned long long rbx ;
   unsigned long long r11 ;
   unsigned long long r10 ;
   unsigned long long r9 ;
   unsigned long long r8 ;
   unsigned long long rax ;
   unsigned long long rcx ;
   unsigned long long rdx ;
   unsigned long long rsi ;
   unsigned long long rdi ;
   unsigned long long orig_rax ;
   unsigned long long rip ;
   unsigned long long cs ;
   unsigned long long eflags ;
   unsigned long long rsp ;
   unsigned long long ss ;
   unsigned long long fs_base ;
   unsigned long long gs_base ;
   unsigned long long ds ;
   unsigned long long es ;
   unsigned long long fs ;
   unsigned long long gs ;
};
extern double sqrt(double x ) ;
int encrypted_flag[43] ;
extern int snprintf(char *str , unsigned int size , char const   *format  , ...) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__,
__alloc_size__(1))) ;
extern long strtol(char const   *str , char const   *endptr , int base ) ;
extern int nanosleep(int *rqtp , int *rmtp ) ;
extern int pthread_mutex_unlock(int *mutex ) ;
extern int atoi(char const   *s ) ;
extern int pthread_create(void *thread , void *attr , void *start_routine , void *arg ) ;
extern int fscanf(struct _IO_FILE *stream , char const   *format  , ...) ;
extern int fseek(struct _IO_FILE *stream , long offs , int whence ) ;
void megaInit(void) ;
int KSA(char *key , unsigned char *S ) ;
void megaInit(void) 
{ 


  {
  encrypted_flag_i$nit();
  fake_rc4_key_i$nit();
  trigger_i$nit();
}
}
_Bool flag_checker(char *flag ) 
{ 
  char key[16] ;
  int i ;
  unsigned char *ciphertext ;
  void *tmp ;
  int bool_flag ;
  size_t tmp___0 ;
  int i___0 ;
  size_t tmp___1 ;
  unsigned long _1_flag_checker_next ;

  {
  {
  _1_flag_checker_next = 10UL;
  }
  while (1) {
    switch (_1_flag_checker_next) {
    case 8: 
    i___0 ++;
    {
    _1_flag_checker_next = 0UL;
    }
    break;
    case 7: ;
    if (encrypted_flag[i___0] != (int )*(ciphertext + i___0)) {
      {
      _1_flag_checker_next = 12UL;
      }
    } else {
      {
      _1_flag_checker_next = 8UL;
      }
    }
    break;
    case 9: 
    key[i] = (char )(fake_rc4_key[i] ^ *trigger);
    i ++;
    {
    _1_flag_checker_next = 13UL;
    }
    break;
    case 14: ;
    return ((_Bool )bool_flag);
    break;
    case 13: ;
    if (i < 16) {
      {
      _1_flag_checker_next = 9UL;
      }
    } else {
      {
      _1_flag_checker_next = 16UL;
      }
    }
    break;
    case 5: 
    bool_flag = 0;
    {
    _1_flag_checker_next = 1UL;
    }
    break;
    case 0: 
    tmp___1 = strlen((char const   *)flag);
    {
    _1_flag_checker_next = 2UL;
    }
    break;
    case 1: 
    i___0 = 0;
    {
    _1_flag_checker_next = 0UL;
    }
    break;
    case 2: ;
    if ((size_t )i___0 < tmp___1) {
      {
      _1_flag_checker_next = 7UL;
      }
    } else {
      {
      _1_flag_checker_next = 14UL;
      }
    }
    break;
    case 12: 
    bool_flag = 0;
    {
    _1_flag_checker_next = 8UL;
    }
    break;
    case 16: 
    tmp = malloc((size_t )(sizeof(char ) * 256U));
    ciphertext = (unsigned char *)tmp;
    RC4(key, flag, ciphertext);
    bool_flag = 1;
    tmp___0 = strlen((char const   *)flag);
    {
    _1_flag_checker_next = 15UL;
    }
    break;
    case 10: 
    i = 0;
    {
    _1_flag_checker_next = 13UL;
    }
    break;
    case 15: ;
    if (tmp___0 < 43UL) {
      {
      _1_flag_checker_next = 5UL;
      }
    } else {
      {
      _1_flag_checker_next = 1UL;
      }
    }
    break;
    }
  }
}
}
int PRGA(unsigned char *S , char *plaintext , unsigned char *ciphertext ) 
{ 
  int i ;
  int j ;
  size_t n ;
  size_t len ;
  size_t tmp ;
  int rnd ;
  unsigned long _1_PRGA_next ;

  {
  {
  _1_PRGA_next = 4UL;
  }
  while (1) {
    switch (_1_PRGA_next) {
    case 0: ;
    return (0);
    break;
    case 5: ;
    if (n < len) {
      {
      _1_PRGA_next = 1UL;
      }
    } else {
      {
      _1_PRGA_next = 0UL;
      }
    }
    break;
    case 4: 
    i = 0;
    j = 0;
    n = (size_t )0;
    tmp = strlen((char const   *)plaintext);
    len = tmp;
    {
    _1_PRGA_next = 5UL;
    }
    break;
    case 1: 
    i = (i + 1) % 256;
    j = (j + (int )*(S + i)) % 256;
    swap(S + i, S + j);
    rnd = (int )*(S + ((int )*(S + i) + (int )*(S + j)) % 256);
    *(ciphertext + n) = (unsigned char )(rnd ^ (int )*(plaintext + n));
    n ++;
    {
    _1_PRGA_next = 5UL;
    }
    break;
    }
  }
}
}
void fake_rc4_key_i$nit(void) 
{ 


  {
  fake_rc4_key[0] = 7;
  fake_rc4_key[1] = 135;
  fake_rc4_key[2] = 134;
  fake_rc4_key[3] = 184;
  fake_rc4_key[4] = 92;
  fake_rc4_key[5] = 43;
  fake_rc4_key[6] = 80;
  fake_rc4_key[7] = 152;
  fake_rc4_key[8] = 59;
  fake_rc4_key[9] = 133;
  fake_rc4_key[10] = 218;
  fake_rc4_key[11] = 38;
  fake_rc4_key[12] = 181;
  fake_rc4_key[13] = 148;
  fake_rc4_key[14] = 17;
  fake_rc4_key[15] = 58;
}
}
int RC4(char *key , char *plaintext , unsigned char *ciphertext ) 
{ 
  unsigned char S[256] ;
  unsigned long _1_RC4_next ;

  {
  {
  _1_RC4_next = 1UL;
  }
  while (1) {
    switch (_1_RC4_next) {
    case 1: 
    KSA(key, S);
    PRGA(S, plaintext, ciphertext);
    {
    _1_RC4_next = 0UL;
    }
    break;
    case 0: ;
    return (0);
    break;
    }
  }
}
}
void trigger_i$nit(void) 
{ 


  {

}
}
void encrypted_flag_i$nit(void) 
{ 


  {
  encrypted_flag[0] = 144;
  encrypted_flag[1] = 73;
  encrypted_flag[2] = 163;
  encrypted_flag[3] = 235;
  encrypted_flag[4] = 125;
  encrypted_flag[5] = 28;
  encrypted_flag[6] = 238;
  encrypted_flag[7] = 196;
  encrypted_flag[8] = 37;
  encrypted_flag[9] = 71;
  encrypted_flag[10] = 42;
  encrypted_flag[11] = 117;
  encrypted_flag[12] = 14;
  encrypted_flag[13] = 128;
  encrypted_flag[14] = 0;
  encrypted_flag[15] = 151;
  encrypted_flag[16] = 157;
  encrypted_flag[17] = 205;
  encrypted_flag[18] = 189;
  encrypted_flag[19] = 181;
  encrypted_flag[20] = 31;
  encrypted_flag[21] = 150;
  encrypted_flag[22] = 207;
  encrypted_flag[23] = 205;
  encrypted_flag[24] = 26;
  encrypted_flag[25] = 39;
  encrypted_flag[26] = 152;
  encrypted_flag[27] = 59;
  encrypted_flag[28] = 185;
  encrypted_flag[29] = 49;
  encrypted_flag[30] = 194;
  encrypted_flag[31] = 97;
  encrypted_flag[32] = 154;
  encrypted_flag[33] = 58;
  encrypted_flag[34] = 179;
  encrypted_flag[35] = 195;
  encrypted_flag[36] = 63;
  encrypted_flag[37] = 191;
  encrypted_flag[38] = 75;
  encrypted_flag[39] = 206;
  encrypted_flag[40] = 184;
  encrypted_flag[41] = 42;
  encrypted_flag[42] = 227;
}
}
int main(int argc , char **argv , char **_formal_envp ) 
{ 
  pid_t main_child_pid ;
  __pid_t tmp ;
  int grandchild_status ;
  struct user_regs_struct regs ;
  pid_t grandchild_pid ;
  __pid_t tmp___0 ;
  _Bool tmp___1 ;
  int tmp___2 ;
  int _BARRIER_0 ;
  unsigned long _1_main_next ;

  {
  megaInit();
  _global_argc = argc;
  _global_argv = argv;
  _global_envp = _formal_envp;
  _BARRIER_0 = 1;
  {
  _1_main_next = 9UL;
  }
  while (1) {
    switch (_1_main_next) {
    case 0: 
    ptrace((enum __ptrace_request )0, 0, 0, 0);
    tmp___1 = flag_checker(*(argv + 1));
    {
    _1_main_next = 19UL;
    }
    break;
    case 15: ;
    if ((grandchild_status & 65280) >> 8 == 11) {
      {
      _1_main_next = 25UL;
      }
    } else {
      {
      _1_main_next = 2UL;
      }
    }
    break;
    case 8: ;
    if (grandchild_status != 65535) {
      {
      _1_main_next = 10UL;
      }
    } else {
      {
      _1_main_next = 1UL;
      }
    }
    break;
    case 9: ;
    {
    _1_main_next = 14UL;
    }
    break;
    case 19: ;
    if (tmp___1) {
      {
      _1_main_next = 7UL;
      }
    } else {
      {
      _1_main_next = 4UL;
      }
    }
    break;
    case 18: 
    tmp___0 = fork();
    grandchild_pid = tmp___0;
    {
    _1_main_next = 11UL;
    }
    break;
    case 13: 
    exit(0);

    break;
    case 14: ;
    if (argc != 2) {
      {
      _1_main_next = 23UL;
      }
    } else {
      {
      _1_main_next = 21UL;
      }
    }
    break;
    case 4: 
    puts("Wrong");
    {
    _1_main_next = 13UL;
    }
    break;
    case 11: ;
    if (grandchild_pid == 0) {
      {
      _1_main_next = 0UL;
      }
    } else {
      {
      _1_main_next = 5UL;
      }
    }
    break;
    case 12: ;
    return (0);
    break;
    case 21: 
    tmp = fork();
    main_child_pid = tmp;
    {
    _1_main_next = 17UL;
    }
    break;
    case 7: 
    puts("Correct");
    {
    _1_main_next = 13UL;
    }
    break;
    case 5: 
    ptrace((enum __ptrace_request )16, grandchild_pid, 0, 0);
    srand(69U);
    {
    _1_main_next = 1UL;
    }
    break;
    case 25: 
    ptrace((enum __ptrace_request )12, grandchild_pid, 0, & regs);
    regs.rip += 2ULL;
    tmp___2 = rand();
    regs.rax = (unsigned long long )tmp___2;
    ptrace((enum __ptrace_request )13, grandchild_pid, 0, & regs);
    {
    _1_main_next = 2UL;
    }
    break;
    case 22: ;
    if ((grandchild_status & 127) == 0) {
      {
      _1_main_next = 20UL;
      }
    } else {
      {
      _1_main_next = 3UL;
      }
    }
    break;
    case 17: ;
    if (main_child_pid == 0) {
      {
      _1_main_next = 18UL;
      }
    } else {
      {
      _1_main_next = 12UL;
      }
    }
    break;
    case 1: 
    waitpid(grandchild_pid, & grandchild_status, 0);
    {
    _1_main_next = 22UL;
    }
    break;
    case 23: 
    puts("Not even close");
    exit(1);

    break;
    case 20: ;
    return (0);
    break;
    case 2: 
    ptrace((enum __ptrace_request )7, grandchild_pid, 0, 0);
    {
    _1_main_next = 1UL;
    }
    break;
    case 3: ;
    if ((int )((signed char )((grandchild_status & 127) + 1)) >> 1 > 0) {
      {
      _1_main_next = 20UL;
      }
    } else {
      {
      _1_main_next = 8UL;
      }
    }
    break;
    case 10: ;
    if ((grandchild_status & 255) == 127) {
      {
      _1_main_next = 15UL;
      }
    } else {
      {
      _1_main_next = 2UL;
      }
    }
    break;
    }
  }
}
}
int KSA(char *key , unsigned char *S ) 
{ 
  int len ;
  int j ;
  int i ;
  int i___0 ;
  unsigned long _1_KSA_next ;

  {
  {
  _1_KSA_next = 11UL;
  }
  while (1) {
    switch (_1_KSA_next) {
    case 11: 
    len = 16;
    j = 0;
    i = 0;
    {
    _1_KSA_next = 1UL;
    }
    break;
    case 8: 
    *(S + i) = (unsigned char )i;
    i ++;
    {
    _1_KSA_next = 1UL;
    }
    break;
    case 3: 
    swap(S + i___0, S + j);
    i___0 ++;
    {
    _1_KSA_next = 4UL;
    }
    break;
    case 0: 
    i___0 = 0;
    {
    _1_KSA_next = 4UL;
    }
    break;
    case 7: ;
    if (j < 0) {
      {
      _1_KSA_next = 10UL;
      }
    } else {
      {
      _1_KSA_next = 3UL;
      }
    }
    break;
    case 1: ;
    if (i < 256) {
      {
      _1_KSA_next = 8UL;
      }
    } else {
      {
      _1_KSA_next = 0UL;
      }
    }
    break;
    case 9: ;
    return (0);
    break;
    case 10: 
    j += 256;
    {
    _1_KSA_next = 3UL;
    }
    break;
    case 6: 
    j = ((j + (int )*(S + i___0)) + (int )*(key + i___0 % len)) % 256;
    {
    _1_KSA_next = 7UL;
    }
    break;
    case 4: ;
    if (i___0 < 256) {
      {
      _1_KSA_next = 6UL;
      }
    } else {
      {
      _1_KSA_next = 9UL;
      }
    }
    break;
    }
  }
}
}
void swap(unsigned char *a , unsigned char *b ) 
{ 
  unsigned char tmp ;
  unsigned long _1_swap_next ;

  {
  {
  _1_swap_next = 0UL;
  }
  while (1) {
    switch (_1_swap_next) {
    case 1: ;
    return;
    break;
    case 0: 
    tmp = *a;
    *a = *b;
    *b = tmp;
    {
    _1_swap_next = 1UL;
    }
    break;
    }
  }
}
}
